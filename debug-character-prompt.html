<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìºë¦­í„° í”„ë¡¬í”„íŠ¸ ìƒì„± ë””ë²„ê¹…</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .result {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            border-left-color: #f44336;
        }
        .success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left-color: #4caf50;
        }
        .warning {
            background: #fff3e0;
            color: #f57c00;
            border-left-color: #ff9800;
        }
        button {
            padding: 12px 24px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 20px;
            background: #e9ecef;
            border-radius: 8px;
        }
        select, input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .character-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ìºë¦­í„° í”„ë¡¬í”„íŠ¸ ìƒì„± ë””ë²„ê¹… ë„êµ¬</h1>

        <div class="test-controls">
            <select id="characterSelect">
                <option value="">ìºë¦­í„° ì„ íƒ...</option>
            </select>

            <select id="styleSelect">
                <option value="comprehensive">Comprehensive</option>
                <option value="roleplay">Roleplay</option>
                <option value="psychological">Psychological</option>
            </select>

            <select id="lengthSelect">
                <option value="short">Short</option>
                <option value="medium">Medium</option>
                <option value="long">Long</option>
            </select>

            <button onclick="testCharacterPrompt()">ğŸ§ª í”„ë¡¬í”„íŠ¸ ìƒì„± í…ŒìŠ¤íŠ¸</button>
            <button onclick="testSanitization()">ğŸ›¡ï¸ Sanitization í…ŒìŠ¤íŠ¸</button>
            <button onclick="testAPIConnection()">ğŸŒ API ì—°ê²° í…ŒìŠ¤íŠ¸</button>
            <button onclick="clearResults()">ğŸ§¹ ê²°ê³¼ ì§€ìš°ê¸°</button>
        </div>

        <div id="results"></div>
    </div>

    <script>
        let characters = {};

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            document.getElementById('results').appendChild(div);

            // ìë™ ìŠ¤í¬ë¡¤
            div.scrollIntoView({ behavior: 'smooth' });
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        // Sanitization í•¨ìˆ˜ë“¤ (APIì™€ ë™ì¼)
        function sanitizeValueForOpenAI(value) {
            if (!value) return value;

            const sanitizationMap = {
                // ì˜ë¥˜/ì•¡ì„¸ì„œë¦¬ ê´€ë ¨
                'luxury_lingerie': 'elegant_accessories',
                'sexy_lingerie': 'elegant_clothing',
                'sensual_lingerie': 'stylish_undergarments',

                // ì™¸ëª¨ ê´€ë ¨ - ë” ê°•í™”
                'seductive_eyes': 'expressive_eyes',
                'sultry_dominant': 'confident_charming',
                'passionate_kiss': 'warm_affection',
                'sultry_gaze': 'charming_gaze',
                'seductive_smile': 'attractive_smile',
                'playful_seductive': 'playful_charming',

                // ìŠ¤í‚¨ì‹­ ê´€ë ¨ - ë” ê°•í™”
                'intimate_cuddling': 'close_bonding',
                'passionate_kiss': 'affectionate_gesture',
                'intimate_touch': 'gentle_touch',
                'sensual_massage': 'relaxing_massage',

                // ì‹ ì²´ ê´€ë ¨ - ê°•í™”
                'D': 'well_proportioned',
                'E': 'full_figured',
                'F': 'curvy',
                'petite_sexy': 'petite_elegant',
                'attractive_chest': 'elegant_posture',

                // ì‹ ì²´ í–‰ë™ - ìƒˆë¡œ ì¶”ê°€
                'ì…ìˆ ê¹¨ë¬¼ê¸°': 'ë¯¸ì†Œì§“ê¸°',
                'ìœ í˜¹ì ì‹œì„ ': 'ë”°ëœ»í•œì‹œì„ ',
                'ì„¹ì‹œ': 'ìš°ì•„',
                'ëª¸ê¸°ìš¸ì´ê¸°': 'ìì—°ìŠ¤ëŸ½ê²Œê¸°ìš¸ì´ê¸°',
                'ìˆ¨ì†Œë¦¬ê±°ì¹ ì–´ì§': 'ê¹Šì€í˜¸í¡',

                // ìŠ¤íƒ€ì¼ ê´€ë ¨
                'sultry_dominant': 'confident_charming',
                'playful_seductive': 'playful_friendly',

                // ê¸°íƒ€ ë¯¼ê°í•œ í‘œí˜„ - ê°•í™”
                'sensual_habits': 'charming_habits',
                'sultry': 'charming',
                'seductive': 'attractive',
                'sensual': 'graceful',
                'erotic': 'romantic',
                'sexual': 'intimate',
                'arousing': 'captivating',
                'sexual_curiosity': 'romantic_curiosity',
                'sexual_comfort': 'emotional_comfort',
                'sexual_freedom': 'emotional_openness',
                'sexual_tone_band': 'conversation_tone',
                'early_teens': 'mature_age',
                'first_experience_age': 'maturity_level'
            };

            if (Array.isArray(value)) {
                return value.map(item => sanitizationMap[item] || item);
            } else {
                return sanitizationMap[value] || value;
            }
        }

        function sanitizeCharacterForOpenAI(character) {
            if (!character) return character;

            // ê¹Šì€ ë³µì‚¬ë¥¼ í†µí•´ ì›ë³¸ ë°ì´í„° ë³´ì¡´
            const sanitizedCharacter = JSON.parse(JSON.stringify(character));

            // ì¬ê·€ì ìœ¼ë¡œ ëª¨ë“  ê°’ ì²˜ë¦¬
            function sanitizeObject(obj) {
                if (!obj || typeof obj !== 'object') return obj;

                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (Array.isArray(obj[key])) {
                            obj[key] = obj[key].map(item =>
                                typeof item === 'string' ? sanitizeValueForOpenAI(item) : item
                            );
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            sanitizeObject(obj[key]);
                        } else if (typeof obj[key] === 'string') {
                            obj[key] = sanitizeValueForOpenAI(obj[key]);
                        }
                    }
                }
            }

            sanitizeObject(sanitizedCharacter);
            return sanitizedCharacter;
        }

        // ìºë¦­í„° ë°ì´í„° ë¡œë“œ
        async function loadCharacters() {
            try {
                log('ğŸ“¥ ìºë¦­í„° ë°ì´í„° ë¡œë“œ ì¤‘...');

                const response = await fetch('/api/character-ai-generator?action=list_characters&_t=' + Date.now());

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.success && result.characters) {
                    characters = result.characters;

                    const select = document.getElementById('characterSelect');
                    select.innerHTML = '<option value="">ìºë¦­í„° ì„ íƒ...</option>';

                    Object.values(characters).forEach(char => {
                        const option = document.createElement('option');
                        option.value = char.id;
                        option.textContent = `${char.basic_info?.name} (${char.basic_info?.mbti})`;
                        select.appendChild(option);
                    });

                    log(`âœ… ${Object.keys(characters).length}ê°œ ìºë¦­í„° ë¡œë“œ ì™„ë£Œ`, 'success');
                } else {
                    throw new Error('ìºë¦­í„° ë°ì´í„° í˜•ì‹ ì˜¤ë¥˜');
                }

            } catch (error) {
                log(`âŒ ìºë¦­í„° ë¡œë“œ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }

        // Sanitization í…ŒìŠ¤íŠ¸
        async function testSanitization() {
            const characterId = document.getElementById('characterSelect').value;
            if (!characterId) {
                log('âš ï¸ ë¨¼ì € ìºë¦­í„°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            const character = characters[characterId];
            if (!character) {
                log('âŒ ì„ íƒí•œ ìºë¦­í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('ğŸ›¡ï¸ Sanitization í…ŒìŠ¤íŠ¸ ì‹œì‘...');

            try {
                // ì›ë³¸ ë°ì´í„° í‘œì‹œ
                log('<details><summary>ğŸ“‹ ì›ë³¸ ìºë¦­í„° ë°ì´í„°</summary><pre>' +
                    JSON.stringify(character, null, 2) + '</pre></details>');

                // Sanitization ì ìš©
                const sanitizedCharacter = sanitizeCharacterForOpenAI(character);

                log('<details><summary>ğŸ›¡ï¸ Sanitized ìºë¦­í„° ë°ì´í„°</summary><pre>' +
                    JSON.stringify(sanitizedCharacter, null, 2) + '</pre></details>');

                // ë³€ê²½ëœ í•„ë“œë“¤ ì°¾ê¸°
                const changes = findChanges(character, sanitizedCharacter);
                if (changes.length > 0) {
                    log(`ğŸ”„ ${changes.length}ê°œ í•„ë“œê°€ ì•ˆì „í•˜ê²Œ ë³€í™˜ë¨:`, 'success');
                    changes.forEach(change => {
                        log(`  â€¢ ${change.path}: "${change.original}" â†’ "${change.sanitized}"`);
                    });
                } else {
                    log('âœ… ì´ë¯¸ ì•ˆì „í•œ ë°ì´í„°ì…ë‹ˆë‹¤', 'success');
                }

            } catch (error) {
                log(`âŒ Sanitization í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }

        // ë³€ê²½ëœ í•„ë“œë“¤ì„ ì°¾ëŠ” í•¨ìˆ˜
        function findChanges(original, sanitized, path = '') {
            const changes = [];

            function compareObjects(orig, san, currentPath) {
                for (const key in orig) {
                    const newPath = currentPath ? `${currentPath}.${key}` : key;

                    if (typeof orig[key] === 'object' && orig[key] !== null && san[key] !== null) {
                        if (Array.isArray(orig[key])) {
                            for (let i = 0; i < orig[key].length; i++) {
                                if (orig[key][i] !== san[key][i]) {
                                    changes.push({
                                        path: `${newPath}[${i}]`,
                                        original: orig[key][i],
                                        sanitized: san[key][i]
                                    });
                                }
                            }
                        } else {
                            compareObjects(orig[key], san[key], newPath);
                        }
                    } else if (orig[key] !== san[key]) {
                        changes.push({
                            path: newPath,
                            original: orig[key],
                            sanitized: san[key]
                        });
                    }
                }
            }

            compareObjects(original, sanitized, path);
            return changes;
        }

        // API ì—°ê²° í…ŒìŠ¤íŠ¸
        async function testAPIConnection() {
            log('ğŸŒ API ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹œì‘...');

            try {
                const response = await fetch('/api/character-ai-generator?action=test&_t=' + Date.now());

                log(`ğŸ“¡ ì‘ë‹µ ìƒíƒœ: ${response.status} ${response.statusText}`);

                if (response.ok) {
                    const result = await response.json();
                    log('âœ… API ì—°ê²° ì„±ê³µ', 'success');
                    log('<pre>' + JSON.stringify(result, null, 2) + '</pre>');
                } else {
                    log('âŒ API ì—°ê²° ì‹¤íŒ¨', 'error');
                    const text = await response.text();
                    log('<pre>' + text + '</pre>');
                }

            } catch (error) {
                log(`âŒ API ì—°ê²° ì˜¤ë¥˜: ${error.message}`, 'error');
            }
        }

        // ì‹¤ì œ í”„ë¡¬í”„íŠ¸ ìƒì„± í…ŒìŠ¤íŠ¸
        async function testCharacterPrompt() {
            const characterId = document.getElementById('characterSelect').value;
            const style = document.getElementById('styleSelect').value;
            const length = document.getElementById('lengthSelect').value;

            if (!characterId) {
                log('âš ï¸ ë¨¼ì € ìºë¦­í„°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            const character = characters[characterId];
            if (!character) {
                log('âŒ ì„ íƒí•œ ìºë¦­í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log(`ğŸš€ í”„ë¡¬í”„íŠ¸ ìƒì„± í…ŒìŠ¤íŠ¸ ì‹œì‘ (${character.basic_info?.name}, ${style}, ${length})`);

            const startTime = Date.now();

            try {
                // ìš”ì²­ ë°ì´í„° ì¤€ë¹„
                const requestData = {
                    action: 'generate_character_prompt',
                    character_data: character,
                    model: 'gpt-4o',
                    style: style,
                    length: length,
                    system_prompt: 'ìºë¦­í„° í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.'
                };

                log('ğŸ“¤ ìš”ì²­ ë°ì´í„° í¬ê¸°: ' + JSON.stringify(requestData).length + ' bytes');

                const response = await fetch('/api/character-ai-generator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                log(`â±ï¸ ì‘ë‹µ ì‹œê°„: ${duration}ms`);
                log(`ğŸ“¡ ì‘ë‹µ ìƒíƒœ: ${response.status} ${response.statusText}`);

                if (response.ok) {
                    const result = await response.json();

                    if (result.success) {
                        if (result.prompt === "I'm sorry, I can't assist with that request.") {
                            log('âŒ OpenAIì—ì„œ ìš”ì²­ì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤', 'error');
                            log('ğŸ” ê±°ë¶€ ì›ì¸ì„ ë¶„ì„í•˜ê¸° ìœ„í•´ Sanitization í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë³´ì„¸ìš”');
                        } else {
                            log('âœ… í”„ë¡¬í”„íŠ¸ ìƒì„± ì„±ê³µ!', 'success');
                            log(`ğŸ“ ìƒì„±ëœ í”„ë¡¬í”„íŠ¸ ê¸¸ì´: ${result.prompt.length}ì`);
                            log(`ğŸ¤– ì‚¬ìš©ëœ ëª¨ë¸: ${result.model_used}`);
                            log(`ğŸ“ ê¸¸ì´ ì„¤ì •: ${result.length}`);

                            log('<details><summary>ğŸ“„ ìƒì„±ëœ í”„ë¡¬í”„íŠ¸ ë‚´ìš©</summary><pre>' +
                                result.prompt + '</pre></details>');
                        }
                    } else {
                        log('âŒ í”„ë¡¬í”„íŠ¸ ìƒì„± ì‹¤íŒ¨', 'error');
                        log(`ì˜¤ë¥˜: ${result.message || result.error}`);
                    }

                    log('<details><summary>ğŸ“Š ì „ì²´ ì‘ë‹µ ë°ì´í„°</summary><pre>' +
                        JSON.stringify(result, null, 2) + '</pre></details>');

                } else {
                    log('âŒ HTTP ìš”ì²­ ì‹¤íŒ¨', 'error');
                    const errorText = await response.text();
                    log('<pre>' + errorText + '</pre>');
                }

            } catch (error) {
                const endTime = Date.now();
                const duration = endTime - startTime;

                log(`âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ (${duration}ms): ${error.message}`, 'error');
                log('<pre>' + error.stack + '</pre>');
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìºë¦­í„° ë°ì´í„° ë¡œë“œ
        window.addEventListener('load', () => {
            log('ğŸ”§ ìºë¦­í„° í”„ë¡¬í”„íŠ¸ ìƒì„± ë””ë²„ê¹… ë„êµ¬ ì¤€ë¹„ ì™„ë£Œ');
            loadCharacters();
        });
    </script>
</body>
</html>