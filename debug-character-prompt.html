<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캐릭터 프롬프트 생성 디버깅</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .result {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            border-left-color: #f44336;
        }
        .success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left-color: #4caf50;
        }
        .warning {
            background: #fff3e0;
            color: #f57c00;
            border-left-color: #ff9800;
        }
        button {
            padding: 12px 24px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 20px;
            background: #e9ecef;
            border-radius: 8px;
        }
        select, input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .character-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 캐릭터 프롬프트 생성 디버깅 도구</h1>

        <div class="test-controls">
            <select id="characterSelect">
                <option value="">캐릭터 선택...</option>
            </select>

            <select id="styleSelect">
                <option value="comprehensive">Comprehensive</option>
                <option value="roleplay">Roleplay</option>
                <option value="psychological">Psychological</option>
            </select>

            <select id="lengthSelect">
                <option value="short">Short</option>
                <option value="medium">Medium</option>
                <option value="long">Long</option>
            </select>

            <button onclick="testCharacterPrompt()">🧪 프롬프트 생성 테스트</button>
            <button onclick="testSanitization()">🛡️ Sanitization 테스트</button>
            <button onclick="testAPIConnection()">🌐 API 연결 테스트</button>
            <button onclick="clearResults()">🧹 결과 지우기</button>
        </div>

        <div id="results"></div>
    </div>

    <script>
        let characters = {};

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            document.getElementById('results').appendChild(div);

            // 자동 스크롤
            div.scrollIntoView({ behavior: 'smooth' });
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        // Sanitization 함수들 (API와 동일)
        function sanitizeValueForOpenAI(value) {
            if (!value) return value;

            const sanitizationMap = {
                // 의류/액세서리 관련
                'luxury_lingerie': 'elegant_accessories',
                'sexy_lingerie': 'elegant_clothing',
                'sensual_lingerie': 'stylish_undergarments',

                // 외모 관련 - 더 강화
                'seductive_eyes': 'expressive_eyes',
                'sultry_dominant': 'confident_charming',
                'passionate_kiss': 'warm_affection',
                'sultry_gaze': 'charming_gaze',
                'seductive_smile': 'attractive_smile',
                'playful_seductive': 'playful_charming',

                // 스킨십 관련 - 더 강화
                'intimate_cuddling': 'close_bonding',
                'passionate_kiss': 'affectionate_gesture',
                'intimate_touch': 'gentle_touch',
                'sensual_massage': 'relaxing_massage',

                // 신체 관련 - 강화
                'D': 'well_proportioned',
                'E': 'full_figured',
                'F': 'curvy',
                'petite_sexy': 'petite_elegant',
                'attractive_chest': 'elegant_posture',

                // 신체 행동 - 새로 추가
                '입술깨물기': '미소짓기',
                '유혹적시선': '따뜻한시선',
                '섹시': '우아',
                '몸기울이기': '자연스럽게기울이기',
                '숨소리거칠어짐': '깊은호흡',

                // 스타일 관련
                'sultry_dominant': 'confident_charming',
                'playful_seductive': 'playful_friendly',

                // 기타 민감한 표현 - 강화
                'sensual_habits': 'charming_habits',
                'sultry': 'charming',
                'seductive': 'attractive',
                'sensual': 'graceful',
                'erotic': 'romantic',
                'sexual': 'intimate',
                'arousing': 'captivating',
                'sexual_curiosity': 'romantic_curiosity',
                'sexual_comfort': 'emotional_comfort',
                'sexual_freedom': 'emotional_openness',
                'sexual_tone_band': 'conversation_tone',
                'early_teens': 'mature_age',
                'first_experience_age': 'maturity_level'
            };

            if (Array.isArray(value)) {
                return value.map(item => sanitizationMap[item] || item);
            } else {
                return sanitizationMap[value] || value;
            }
        }

        function sanitizeCharacterForOpenAI(character) {
            if (!character) return character;

            // 깊은 복사를 통해 원본 데이터 보존
            const sanitizedCharacter = JSON.parse(JSON.stringify(character));

            // 재귀적으로 모든 값 처리
            function sanitizeObject(obj) {
                if (!obj || typeof obj !== 'object') return obj;

                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (Array.isArray(obj[key])) {
                            obj[key] = obj[key].map(item =>
                                typeof item === 'string' ? sanitizeValueForOpenAI(item) : item
                            );
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            sanitizeObject(obj[key]);
                        } else if (typeof obj[key] === 'string') {
                            obj[key] = sanitizeValueForOpenAI(obj[key]);
                        }
                    }
                }
            }

            sanitizeObject(sanitizedCharacter);
            return sanitizedCharacter;
        }

        // 캐릭터 데이터 로드
        async function loadCharacters() {
            try {
                log('📥 캐릭터 데이터 로드 중...');

                const response = await fetch('/api/character-ai-generator?action=list_characters&_t=' + Date.now());

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.success && result.characters) {
                    characters = result.characters;

                    const select = document.getElementById('characterSelect');
                    select.innerHTML = '<option value="">캐릭터 선택...</option>';

                    Object.values(characters).forEach(char => {
                        const option = document.createElement('option');
                        option.value = char.id;
                        option.textContent = `${char.basic_info?.name} (${char.basic_info?.mbti})`;
                        select.appendChild(option);
                    });

                    log(`✅ ${Object.keys(characters).length}개 캐릭터 로드 완료`, 'success');
                } else {
                    throw new Error('캐릭터 데이터 형식 오류');
                }

            } catch (error) {
                log(`❌ 캐릭터 로드 실패: ${error.message}`, 'error');
            }
        }

        // Sanitization 테스트
        async function testSanitization() {
            const characterId = document.getElementById('characterSelect').value;
            if (!characterId) {
                log('⚠️ 먼저 캐릭터를 선택해주세요', 'warning');
                return;
            }

            const character = characters[characterId];
            if (!character) {
                log('❌ 선택한 캐릭터를 찾을 수 없습니다', 'error');
                return;
            }

            log('🛡️ Sanitization 테스트 시작...');

            try {
                // 원본 데이터 표시
                log('<details><summary>📋 원본 캐릭터 데이터</summary><pre>' +
                    JSON.stringify(character, null, 2) + '</pre></details>');

                // Sanitization 적용
                const sanitizedCharacter = sanitizeCharacterForOpenAI(character);

                log('<details><summary>🛡️ Sanitized 캐릭터 데이터</summary><pre>' +
                    JSON.stringify(sanitizedCharacter, null, 2) + '</pre></details>');

                // 변경된 필드들 찾기
                const changes = findChanges(character, sanitizedCharacter);
                if (changes.length > 0) {
                    log(`🔄 ${changes.length}개 필드가 안전하게 변환됨:`, 'success');
                    changes.forEach(change => {
                        log(`  • ${change.path}: "${change.original}" → "${change.sanitized}"`);
                    });
                } else {
                    log('✅ 이미 안전한 데이터입니다', 'success');
                }

            } catch (error) {
                log(`❌ Sanitization 테스트 실패: ${error.message}`, 'error');
            }
        }

        // 변경된 필드들을 찾는 함수
        function findChanges(original, sanitized, path = '') {
            const changes = [];

            function compareObjects(orig, san, currentPath) {
                for (const key in orig) {
                    const newPath = currentPath ? `${currentPath}.${key}` : key;

                    if (typeof orig[key] === 'object' && orig[key] !== null && san[key] !== null) {
                        if (Array.isArray(orig[key])) {
                            for (let i = 0; i < orig[key].length; i++) {
                                if (orig[key][i] !== san[key][i]) {
                                    changes.push({
                                        path: `${newPath}[${i}]`,
                                        original: orig[key][i],
                                        sanitized: san[key][i]
                                    });
                                }
                            }
                        } else {
                            compareObjects(orig[key], san[key], newPath);
                        }
                    } else if (orig[key] !== san[key]) {
                        changes.push({
                            path: newPath,
                            original: orig[key],
                            sanitized: san[key]
                        });
                    }
                }
            }

            compareObjects(original, sanitized, path);
            return changes;
        }

        // API 연결 테스트
        async function testAPIConnection() {
            log('🌐 API 연결 테스트 시작...');

            try {
                const response = await fetch('/api/character-ai-generator?action=test&_t=' + Date.now());

                log(`📡 응답 상태: ${response.status} ${response.statusText}`);

                if (response.ok) {
                    const result = await response.json();
                    log('✅ API 연결 성공', 'success');
                    log('<pre>' + JSON.stringify(result, null, 2) + '</pre>');
                } else {
                    log('❌ API 연결 실패', 'error');
                    const text = await response.text();
                    log('<pre>' + text + '</pre>');
                }

            } catch (error) {
                log(`❌ API 연결 오류: ${error.message}`, 'error');
            }
        }

        // 실제 프롬프트 생성 테스트
        async function testCharacterPrompt() {
            const characterId = document.getElementById('characterSelect').value;
            const style = document.getElementById('styleSelect').value;
            const length = document.getElementById('lengthSelect').value;

            if (!characterId) {
                log('⚠️ 먼저 캐릭터를 선택해주세요', 'warning');
                return;
            }

            const character = characters[characterId];
            if (!character) {
                log('❌ 선택한 캐릭터를 찾을 수 없습니다', 'error');
                return;
            }

            log(`🚀 프롬프트 생성 테스트 시작 (${character.basic_info?.name}, ${style}, ${length})`);

            const startTime = Date.now();

            try {
                // 요청 데이터 준비
                const requestData = {
                    action: 'generate_character_prompt',
                    character_data: character,
                    model: 'gpt-4o',
                    style: style,
                    length: length,
                    system_prompt: '캐릭터 프롬프트를 생성해주세요.'
                };

                log('📤 요청 데이터 크기: ' + JSON.stringify(requestData).length + ' bytes');

                const response = await fetch('/api/character-ai-generator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                log(`⏱️ 응답 시간: ${duration}ms`);
                log(`📡 응답 상태: ${response.status} ${response.statusText}`);

                if (response.ok) {
                    const result = await response.json();

                    if (result.success) {
                        if (result.prompt === "I'm sorry, I can't assist with that request.") {
                            log('❌ OpenAI에서 요청을 거부했습니다', 'error');
                            log('🔍 거부 원인을 분석하기 위해 Sanitization 테스트를 실행해보세요');
                        } else {
                            log('✅ 프롬프트 생성 성공!', 'success');
                            log(`📝 생성된 프롬프트 길이: ${result.prompt.length}자`);
                            log(`🤖 사용된 모델: ${result.model_used}`);
                            log(`📏 길이 설정: ${result.length}`);

                            log('<details><summary>📄 생성된 프롬프트 내용</summary><pre>' +
                                result.prompt + '</pre></details>');
                        }
                    } else {
                        log('❌ 프롬프트 생성 실패', 'error');
                        log(`오류: ${result.message || result.error}`);
                    }

                    log('<details><summary>📊 전체 응답 데이터</summary><pre>' +
                        JSON.stringify(result, null, 2) + '</pre></details>');

                } else {
                    log('❌ HTTP 요청 실패', 'error');
                    const errorText = await response.text();
                    log('<pre>' + errorText + '</pre>');
                }

            } catch (error) {
                const endTime = Date.now();
                const duration = endTime - startTime;

                log(`❌ 테스트 실패 (${duration}ms): ${error.message}`, 'error');
                log('<pre>' + error.stack + '</pre>');
            }
        }

        // 페이지 로드 시 캐릭터 데이터 로드
        window.addEventListener('load', () => {
            log('🔧 캐릭터 프롬프트 생성 디버깅 도구 준비 완료');
            loadCharacters();
        });
    </script>
</body>
</html>