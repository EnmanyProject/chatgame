<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 프롬프트 생성 검증 도구</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .section {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .character-data {
            background: #e8f4fd;
            border-left-color: #1976d2;
        }
        .generated-prompt {
            background: #f3e5f5;
            border-left-color: #8e24aa;
        }
        .analysis {
            background: #fff3e0;
            border-left-color: #f57c00;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .field-match {
            background: #d4edda;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
            border-left: 3px solid #28a745;
        }
        .field-missing {
            background: #f8d7da;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
            border-left: 3px solid #dc3545;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: #667eea;
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            vertical-align: top;
        }
        .comparison-table th {
            background: #667eea;
            color: white;
        }
        .comparison-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        .match-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .match-yes { background: #d4edda; color: #155724; }
        .match-partial { background: #fff3cd; color: #856404; }
        .match-no { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 AI 프롬프트 생성 정확도 검증 도구</h1>
        <p>캐릭터 데이터와 생성된 AI 프롬프트 간의 일치도를 상세 분석합니다.</p>

        <div class="section">
            <h3>🎯 테스트 설정</h3>
            <label for="characterSelect">캐릭터 선택:</label>
            <select id="characterSelect">
                <option value="">캐릭터를 선택하세요</option>
            </select>

            <label for="promptStyle">프롬프트 스타일:</label>
            <select id="promptStyle">
                <option value="comprehensive">종합형</option>
                <option value="roleplay">롤플레이형</option>
                <option value="psychological">심리분석형</option>
            </select>

            <button onclick="runAccuracyTest()">🔍 정확도 테스트 실행</button>
            <button onclick="loadCharacterList()">🔄 캐릭터 목록 새로고침</button>
        </div>

        <div id="results" style="display: none;">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="accuracyScore">-</div>
                    <div>정확도 점수</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="fieldsMatched">-</div>
                    <div>매칭된 필드</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalFields">-</div>
                    <div>전체 필드</div>
                </div>
            </div>

            <div class="section character-data">
                <h3>📋 원본 캐릭터 데이터</h3>
                <pre id="originalData"></pre>
            </div>

            <div class="section generated-prompt">
                <h3>🤖 생성된 AI 프롬프트</h3>
                <pre id="generatedPrompt"></pre>
            </div>

            <div class="section analysis">
                <h3>📊 상세 분석 결과</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>필드</th>
                            <th>원본 데이터</th>
                            <th>프롬프트 반영</th>
                            <th>매칭 상태</th>
                        </tr>
                    </thead>
                    <tbody id="analysisTable">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let characters = {};

        // 페이지 로드 시 캐릭터 목록 로드
        window.addEventListener('load', loadCharacterList);

        async function loadCharacterList() {
            try {
                console.log('📋 캐릭터 목록 로드 중...');
                const response = await fetch('/api/character-ai-generator?action=list_characters&_t=' + Date.now());
                const result = await response.json();

                console.log('📥 API 응답:', result);

                if (result.success) {
                    characters = result.characters || result.data?.characters || {};

                    const select = document.getElementById('characterSelect');
                    select.innerHTML = '<option value="">캐릭터를 선택하세요</option>';

                    Object.entries(characters).forEach(([id, character]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = `${character.basic_info?.name || id} (${character.basic_info?.mbti || 'MBTI미정'})`;
                        select.appendChild(option);
                    });

                    console.log(`✅ ${Object.keys(characters).length}개 캐릭터 로드 완료`);
                } else {
                    throw new Error(result.message || '캐릭터 목록 로드 실패');
                }
            } catch (error) {
                console.error('❌ 캐릭터 목록 로드 실패:', error);
                alert('캐릭터 목록을 불러올 수 없습니다.');
            }
        }

        async function runAccuracyTest() {
            const selectedCharacterId = document.getElementById('characterSelect').value;
            const promptStyle = document.getElementById('promptStyle').value;

            if (!selectedCharacterId) {
                alert('캐릭터를 선택해주세요.');
                return;
            }

            const character = characters[selectedCharacterId];
            if (!character) {
                alert('선택한 캐릭터 데이터를 찾을 수 없습니다.');
                return;
            }

            try {
                console.log('🔍 정확도 테스트 시작...');

                // 버튼 비활성화
                const testButton = document.querySelector('button[onclick="runAccuracyTest()"]');
                testButton.disabled = true;
                testButton.innerHTML = '<span class="loading"></span> 분석 중...';

                // AI 프롬프트 생성
                const generatedPrompt = await generatePromptForTest(character, promptStyle);

                // 결과 분석
                const analysis = analyzePromptAccuracy(character, generatedPrompt);

                // 결과 표시
                displayResults(character, generatedPrompt, analysis);

                console.log('✅ 정확도 테스트 완료');

            } catch (error) {
                console.error('❌ 테스트 실패:', error);
                alert('테스트 실행에 실패했습니다: ' + error.message);
            } finally {
                // 버튼 복원
                const testButton = document.querySelector('button[onclick="runAccuracyTest()"]');
                testButton.disabled = false;
                testButton.innerHTML = '🔍 정확도 테스트 실행';
            }
        }

        async function generatePromptForTest(character, style) {
            const response = await fetch('/api/character-ai-generator', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'generate_character_prompt',
                    character_data: character,
                    model: 'gpt-4o',
                    style: style,
                    length: 'long',
                    system_prompt: `당신은 캐릭터 분석 전문가입니다. 제공된 캐릭터 데이터의 모든 세부사항을 빠짐없이 포함하여 매우 상세한 캐릭터 프로필을 작성해야 합니다.

반드시 포함해야 할 요소들:
📋 기본 정보: 이름, 나이, MBTI, 직업, 성별 (모든 항목 필수)
✨ 매력 프로필: 매력 스타일, 매력 포인트, 감정지능, 자신감, 신비로움, 호기심 정도, 개방성, 취미 (수치와 배열 모두 구체적으로)
👄 외모적 특징: 헤어스타일, 눈 모양, 체형, 체격, 허리라인, 패션스타일, 특징적 요소, 우아한 습관, 표현력 (모든 외모 요소 세밀하게)
🧠 심리적 깊이: 핵심 욕구, 취약점, 가치관, 개방성 정도, 편안함 수준, 발전 속도, 소통 스타일 (심리적 특성 완전히)
💬 대화 역학: 말투, 매력적 대화법, 대화 주제, 말 습관, 어휘 수준, 선호 주제, 피하는 주제, 반응 패턴 (모든 대화 스타일)
💕 과거 경험: 연애 경험, 관계 이력, 선호하는 친밀감 표현, 인생 경험 (과거 이력 전체)
🎁 선호도: 좋아하는 선물, 이상형 기준 (선호사항 명시)
🎯 미래 목표: 자산 목표, 미래 직업 (목표와 계획)

작성 지침:
- 최소 8000자 이상의 매우 상세한 설명 (더 길수록 좋음)
- 제공된 모든 수치(점수)를 정확히 언급 (감정지능, 자신감, 신비로움, 성적 호기심, 성적 편안함, 성적 자유도 등)
- 배열 데이터의 모든 항목을 개별적으로 상세 설명 (매력포인트, 취미, 특징적 요소, 감각적 습관, 바디랭귀지, 핵심욕구, 취약점, 플러팅패턴, 대화주제, 말습관, 허용모티프, 금기단어, 선호스킨십, 좋아하는선물, 남성우선순위, 미래직업 등)
- 외모의 모든 세부사항 포함 (헤어스타일, 눈, 체형, 가슴사이즈, 허리/힙, 패션스타일)
- 심리적 특성 완전 포함 (가치관, 편안함수준, 발전속도, 성적톤)
- 대화 역학 전체 포함 (말투, 어휘수준, 반응패턴)
- 과거 경험 완전 포함 (연애경험, 남자친구수, 첫경험나이)
- 미래 목표 완전 포함 (자산목표, 미래직업)
- 자연스럽고 매력적인 한국어로 작성
- 캐릭터가 생생하게 느껴지도록 극도로 구체적으로 묘사
- 15000토큰 한도 내에서 최대한 길고 상세하게 작성

절대 생략하지 말 것: 55개 캐릭터 필드를 모두 빠짐없이 포함해야 합니다. 하나라도 누락하면 안 됩니다.`
                })
            });

            const result = await response.json();

            if (result.success && result.prompt) {
                return result.prompt;
            } else {
                throw new Error(result.error || '프롬프트 생성 실패');
            }
        }

        // 한국어 번역 매핑 (API의 translateToKorean 함수와 동일)
        function getKoreanTranslation(englishValue) {
            const translations = {
                // MBTI
                'INFP': 'INFP', 'ENFP': 'ENFP', 'INTJ': 'INTJ', 'ESTJ': 'ESTJ', 'ESFP': 'ESFP',
                'ISTP': 'ISTP', 'ESFJ': 'ESFJ', 'ISFJ': 'ISFJ', 'ENTP': 'ENTP', 'ENTJ': 'ENTJ',

                // 취미 (hobbies)
                'gaming': '게임', 'reading': '독서', 'cooking': '요리', 'shopping': '쇼핑',
                'traveling': '여행', 'photography': '사진', 'music': '음악', 'dancing': '춤',
                'art': '미술', 'sports': '운동', 'hiking': '등산', 'swimming': '수영',
                'movies': '영화', 'books': '책', 'fitness': '피트니스', 'yoga': '요가',

                // 음식 선호도 (food_preference)
                'Korean food': '한식', 'Italian food': '이탈리안', 'Japanese food': '일식',
                'Chinese food': '중식', 'Western food': '양식', 'vegetarian': '채식',
                'spicy food': '매운음식', 'sweet food': '단음식', 'healthy food': '건강식',

                // 패션 스타일 (fashion_style)
                'casual': '캐주얼', 'elegant': '우아한', 'sporty': '스포티', 'vintage': '빈티지',
                'minimalist': '미니멀', 'bohemian': '보헤미안', 'preppy': '프레피', 'cute': '귀여운',

                // 라이프스타일 (lifestyle)
                'active': '활동적', 'relaxed': '여유로운', 'busy': '바쁜', 'social': '사교적',
                'quiet': '조용한', 'adventurous': '모험적', 'homebody': '집순이',

                // 성격 키워드 (personality_keywords)
                'cheerful': '밝은', 'shy': '수줍은', 'confident': '자신감있는', 'kind': '친절한',
                'funny': '재미있는', 'serious': '진지한', 'creative': '창의적', 'logical': '논리적',
                'emotional': '감정적', 'rational': '이성적', 'optimistic': '낙관적', 'realistic': '현실적',

                // 기타 번역들
                'mysterious': '신비로운', 'charming': '매력적인', 'intelligent': '지적인',
                'playful': '장난스러운', 'warm': '따뜻한', 'cool': '쿨한', 'passionate': '열정적인'
            };

            return translations[englishValue] || englishValue;
        }

        // 향상된 매칭 함수 - 원본 영어값과 한국어 번역 모두 체크
        function checkValueInPrompt(prompt, value) {
            if (!value) return { matched: false, type: 'none' };

            const promptLower = prompt.toLowerCase();

            if (Array.isArray(value)) {
                // 배열인 경우 각 요소를 체크
                for (const item of value) {
                    const original = String(item).toLowerCase();
                    const translated = getKoreanTranslation(String(item)).toLowerCase();

                    if (promptLower.includes(original) || promptLower.includes(translated)) {
                        return { matched: true, type: 'full', matchedValue: item };
                    }
                }
                return { matched: false, type: 'none' };
            } else {
                const original = String(value).toLowerCase();
                const translated = getKoreanTranslation(String(value)).toLowerCase();

                if (promptLower.includes(original) || promptLower.includes(translated)) {
                    return { matched: true, type: 'full', matchedValue: value };
                }

                // 부분 매칭 체크
                const words = original.split(/[,\s]+/).filter(w => w.length > 1);
                const translatedWords = translated.split(/[,\s]+/).filter(w => w.length > 1);

                for (const word of [...words, ...translatedWords]) {
                    if (promptLower.includes(word)) {
                        return { matched: true, type: 'partial', matchedValue: word };
                    }
                }

                return { matched: false, type: 'none' };
            }
        }

        function analyzePromptAccuracy(character, prompt) {
            const analysis = {
                matches: [],
                misses: [],
                accuracyScore: 0
            };

            // 분석할 필드들 정의 - 전체 55개 필드
            const fieldsToCheck = [
                // 📋 기본 정보 (5개)
                { path: 'basic_info.name', label: '이름', getValue: (c) => c.basic_info?.name },
                { path: 'basic_info.age', label: '나이', getValue: (c) => c.basic_info?.age },
                { path: 'basic_info.mbti', label: 'MBTI', getValue: (c) => c.basic_info?.mbti },
                { path: 'basic_info.occupation', label: '직업', getValue: (c) => c.basic_info?.occupation },
                { path: 'basic_info.gender', label: '성별', getValue: (c) => c.basic_info?.gender },

                // ✨ 매력 프로필 (8개)
                { path: 'appeal_profile.seduction_style', label: '매력 스타일', getValue: (c) => c.appeal_profile?.seduction_style },
                { path: 'appeal_profile.charm_points', label: '매력 포인트', getValue: (c) => c.appeal_profile?.charm_points?.join(', ') },
                { path: 'appeal_profile.emotional_intelligence', label: '감정지능', getValue: (c) => c.appeal_profile?.emotional_intelligence },
                { path: 'appeal_profile.confidence_level', label: '자신감', getValue: (c) => c.appeal_profile?.confidence_level },
                { path: 'appeal_profile.mystery_factor', label: '신비로움', getValue: (c) => c.appeal_profile?.mystery_factor },
                { path: 'appeal_profile.sexual_curiosity', label: '성적 호기심', getValue: (c) => c.appeal_profile?.sexual_curiosity },
                { path: 'appeal_profile.sexual_comfort', label: '성적 편안함', getValue: (c) => c.appeal_profile?.sexual_comfort },
                { path: 'appeal_profile.hobbies', label: '취미', getValue: (c) => c.appeal_profile?.hobbies },

                // 👄 외모적 매력 (9개)
                { path: 'physical_allure.appearance.hair', label: '헤어스타일', getValue: (c) => c.physical_allure?.appearance?.hair },
                { path: 'physical_allure.appearance.eyes', label: '눈', getValue: (c) => c.physical_allure?.appearance?.eyes },
                { path: 'physical_allure.appearance.body', label: '체형', getValue: (c) => c.physical_allure?.appearance?.body },
                { path: 'physical_allure.appearance.bust', label: '가슴 사이즈', getValue: (c) => c.physical_allure?.appearance?.bust },
                { path: 'physical_allure.appearance.waist_hip', label: '허리/힙', getValue: (c) => c.physical_allure?.appearance?.waist_hip },
                { path: 'physical_allure.appearance.style', label: '스타일', getValue: (c) => c.physical_allure?.appearance?.style },
                { path: 'physical_allure.feature_elements', label: '특징적 요소', getValue: (c) => c.physical_allure?.feature_elements },
                { path: 'physical_allure.sensual_habits', label: '감각적 습관', getValue: (c) => c.physical_allure?.sensual_habits },
                { path: 'physical_allure.body_language', label: '바디랭귀지', getValue: (c) => c.physical_allure?.body_language },

                // 🧠 심리적 깊이 (6개)
                { path: 'psychological_depth.core_desires', label: '핵심 욕구', getValue: (c) => c.psychological_depth?.core_desires },
                { path: 'psychological_depth.vulnerabilities', label: '취약점', getValue: (c) => c.psychological_depth?.vulnerabilities?.join(', ') },
                { path: 'psychological_depth.values', label: '가치관', getValue: (c) => c.psychological_depth?.values },
                { path: 'psychological_depth.sexual_freedom', label: '성적 자유도', getValue: (c) => c.psychological_depth?.sexual_freedom },
                { path: 'psychological_depth.boundaries.comfort_level', label: '편안함 수준', getValue: (c) => c.psychological_depth?.boundaries?.comfort_level },
                { path: 'psychological_depth.boundaries.escalation_pace', label: '발전 속도', getValue: (c) => c.psychological_depth?.boundaries?.escalation_pace },
                { path: 'psychological_depth.boundaries.sexual_tone_band', label: '성적 톤', getValue: (c) => c.psychological_depth?.boundaries?.sexual_tone_band },

                // 💬 대화 역학 (9개)
                { path: 'conversation_dynamics.speech_style', label: '말투', getValue: (c) => c.conversation_dynamics?.speech_style },
                { path: 'conversation_dynamics.flirting_patterns', label: '플러팅 패턴', getValue: (c) => c.conversation_dynamics?.flirting_patterns?.join(', ') },
                { path: 'conversation_dynamics.conversation_hooks', label: '대화 주제', getValue: (c) => c.conversation_dynamics?.conversation_hooks?.join(', ') },
                { path: 'conversation_dynamics.speech_habits', label: '말 습관', getValue: (c) => c.conversation_dynamics?.speech_habits?.join(', ') },
                { path: 'conversation_dynamics.vocabulary_register', label: '어휘 수준', getValue: (c) => c.conversation_dynamics?.vocabulary_register },
                { path: 'conversation_dynamics.allowed_motifs', label: '허용 모티프', getValue: (c) => c.conversation_dynamics?.allowed_motifs?.join(', ') },
                { path: 'conversation_dynamics.forbidden_terms', label: '금기 단어', getValue: (c) => c.conversation_dynamics?.forbidden_terms?.join(', ') },
                { path: 'conversation_dynamics.reaction_tendencies.humor', label: '유머 반응', getValue: (c) => c.conversation_dynamics?.reaction_tendencies?.humor },
                { path: 'conversation_dynamics.reaction_tendencies.compliment', label: '칭찬 반응', getValue: (c) => c.conversation_dynamics?.reaction_tendencies?.compliment },
                { path: 'conversation_dynamics.reaction_tendencies.interest_expression', label: '관심 표현', getValue: (c) => c.conversation_dynamics?.reaction_tendencies?.interest_expression },

                // 💕 과거 경험 (4개)
                { path: 'past_history.boyfriend_count', label: '남자친구 수', getValue: (c) => c.past_history?.boyfriend_count },
                { path: 'past_history.preferred_skinship', label: '선호 스킨십', getValue: (c) => c.past_history?.preferred_skinship?.join(', ') },
                { path: 'past_history.relationship_experience', label: '연애 경험', getValue: (c) => c.past_history?.relationship_experience },
                { path: 'past_history.first_experience_age', label: '첫 경험 나이', getValue: (c) => c.past_history?.first_experience_age },

                // 🎁 기타 정보 (4개)
                { path: 'favorite_gifts', label: '좋아하는 선물', getValue: (c) => c.favorite_gifts?.join(', ') },
                { path: 'male_priorities', label: '남성 우선순위', getValue: (c) => c.male_priorities?.join(', ') },
                { path: 'future_goals.asset_goal', label: '자산 목표', getValue: (c) => c.future_goals?.asset_goal },
                { path: 'future_goals.future_careers', label: '미래 직업', getValue: (c) => c.future_goals?.future_careers?.join(', ') || '없음' }
            ];

            let totalMatches = 0;

            fieldsToCheck.forEach(field => {
                const value = field.getValue(character);
                if (value) {
                    const matchResult = checkValueInPrompt(prompt, value);
                    let matchStatus = 'no';

                    if (matchResult.matched) {
                        if (matchResult.type === 'full') {
                            matchStatus = 'yes';
                            totalMatches++;
                        } else if (matchResult.type === 'partial') {
                            matchStatus = 'partial';
                            totalMatches += 0.5;
                        }
                    }

                    analysis[matchStatus === 'no' ? 'misses' : 'matches'].push({
                        field: field.label,
                        originalValue: value,
                        matchStatus: matchStatus,
                        inPrompt: matchStatus !== 'no',
                        matchedValue: matchResult.matchedValue || null
                    });
                }
            });

            analysis.accuracyScore = Math.round((totalMatches / fieldsToCheck.length) * 100);
            return analysis;
        }

        function displayResults(character, prompt, analysis) {
            // 통계 표시
            document.getElementById('accuracyScore').textContent = analysis.accuracyScore + '%';
            document.getElementById('fieldsMatched').textContent = Math.floor(analysis.accuracyScore * 41 / 100);
            document.getElementById('totalFields').textContent = '41';

            // 원본 데이터 표시
            document.getElementById('originalData').textContent = JSON.stringify(character, null, 2);

            // 생성된 프롬프트 표시
            document.getElementById('generatedPrompt').textContent = prompt;

            // 분석 테이블 표시
            const tableBody = document.getElementById('analysisTable');
            tableBody.innerHTML = '';

            [...analysis.matches, ...analysis.misses].forEach(item => {
                const row = tableBody.insertRow();
                const statusText = item.inPrompt ? '✅ 반영됨' : '❌ 반영안됨';
                const matchText = item.matchStatus === 'yes' ? '완전매칭' :
                                item.matchStatus === 'partial' ? '부분매칭' : '매칭안됨';
                const matchedInfo = item.matchedValue ? ` (매칭: "${item.matchedValue}")` : '';

                row.innerHTML = `
                    <td>${item.field}</td>
                    <td>${item.originalValue}</td>
                    <td>${statusText}${matchedInfo}</td>
                    <td><span class="match-status match-${item.matchStatus}">${matchText}</span></td>
                `;
            });

            // 결과 섹션 표시
            document.getElementById('results').style.display = 'block';
        }
    </script>
</body>
</html>